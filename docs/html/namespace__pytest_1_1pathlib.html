<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FoodMart: _pytest.pathlib Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">FoodMart
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace__pytest.html">_pytest</a></li><li class="navelem"><a class="el" href="namespace__pytest_1_1pathlib.html">pathlib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">_pytest.pathlib Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1CouldNotResolvePathError.html">CouldNotResolvePathError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1ImportMode.html">ImportMode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class__pytest_1_1pathlib_1_1ImportPathMismatchError.html">ImportPathMismatchError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a49fb18e734de79bf93247d67a201673b" id="r_a49fb18e734de79bf93247d67a201673b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a49fb18e734de79bf93247d67a201673b">_ignore_error</a> (Exception exception)</td></tr>
<tr class="separator:a49fb18e734de79bf93247d67a201673b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cc9f2b91e8d7c2f31e80cc596fc1ad" id="r_a71cc9f2b91e8d7c2f31e80cc596fc1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a71cc9f2b91e8d7c2f31e80cc596fc1ad">get_lock_path</a> (<a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> path)</td></tr>
<tr class="separator:a71cc9f2b91e8d7c2f31e80cc596fc1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abdcb5994f4fa50d164263b77b2e17c" id="r_a1abdcb5994f4fa50d164263b77b2e17c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a1abdcb5994f4fa50d164263b77b2e17c">on_rm_rf_error</a> (Callable[..., Any]|None func, str path, BaseException|tuple[type[BaseException], BaseException, types.TracebackType|None] excinfo, *Path start_path)</td></tr>
<tr class="separator:a1abdcb5994f4fa50d164263b77b2e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8b0325e6efac0c038f9a724ab8a2bf" id="r_a6b8b0325e6efac0c038f9a724ab8a2bf"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6b8b0325e6efac0c038f9a724ab8a2bf">ensure_extended_length_path</a> (Path path)</td></tr>
<tr class="separator:a6b8b0325e6efac0c038f9a724ab8a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae544da450e5c7c6870a70be7cabc75d8" id="r_ae544da450e5c7c6870a70be7cabc75d8"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae544da450e5c7c6870a70be7cabc75d8">get_extended_length_path_str</a> (str path)</td></tr>
<tr class="separator:ae544da450e5c7c6870a70be7cabc75d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f0c08537ab64dd461cfb6674625b38" id="r_ae1f0c08537ab64dd461cfb6674625b38"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae1f0c08537ab64dd461cfb6674625b38">rm_rf</a> (Path path)</td></tr>
<tr class="separator:ae1f0c08537ab64dd461cfb6674625b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1843653a064d8dee4dcf9a5cc00679c" id="r_ab1843653a064d8dee4dcf9a5cc00679c"><td class="memItemLeft" align="right" valign="top">Iterator[os.DirEntry[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ab1843653a064d8dee4dcf9a5cc00679c">find_prefixed</a> (Path root, str prefix)</td></tr>
<tr class="separator:ab1843653a064d8dee4dcf9a5cc00679c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0addba70a654b247e36cb4401bc7dc12" id="r_a0addba70a654b247e36cb4401bc7dc12"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a0addba70a654b247e36cb4401bc7dc12">extract_suffixes</a> (Iterable[os.DirEntry[str]] iter, str prefix)</td></tr>
<tr class="separator:a0addba70a654b247e36cb4401bc7dc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a66215e40cad20f751eddc3c6e8721" id="r_ae5a66215e40cad20f751eddc3c6e8721"><td class="memItemLeft" align="right" valign="top">Iterator[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae5a66215e40cad20f751eddc3c6e8721">find_suffixes</a> (Path root, str prefix)</td></tr>
<tr class="separator:ae5a66215e40cad20f751eddc3c6e8721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6232b74550a186a8206597eefc3737" id="r_aef6232b74550a186a8206597eefc3737"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#aef6232b74550a186a8206597eefc3737">parse_num</a> (str maybe_num)</td></tr>
<tr class="separator:aef6232b74550a186a8206597eefc3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d36d17900127934577a8859d235bcfd" id="r_a2d36d17900127934577a8859d235bcfd"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a2d36d17900127934577a8859d235bcfd">_force_symlink</a> (Path root, str|PurePath target, str|Path link_to)</td></tr>
<tr class="separator:a2d36d17900127934577a8859d235bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca62f92c9e61a349836eadf38245d85" id="r_a6ca62f92c9e61a349836eadf38245d85"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6ca62f92c9e61a349836eadf38245d85">make_numbered_dir</a> (Path root, str prefix, int mode=0o700)</td></tr>
<tr class="separator:a6ca62f92c9e61a349836eadf38245d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fae1b99c0fbb9d314aceb95e668a401" id="r_a2fae1b99c0fbb9d314aceb95e668a401"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a2fae1b99c0fbb9d314aceb95e668a401">create_cleanup_lock</a> (Path p)</td></tr>
<tr class="separator:a2fae1b99c0fbb9d314aceb95e668a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e8d477b40f4178236b4e1a1465e550" id="r_a18e8d477b40f4178236b4e1a1465e550"><td class="memItemLeft" align="right" valign="top">Any&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a18e8d477b40f4178236b4e1a1465e550">register_cleanup_lock_removal</a> (Path lock_path, Any register=atexit.register)</td></tr>
<tr class="separator:a18e8d477b40f4178236b4e1a1465e550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e58fca02f174fa9bd72475840e51cc" id="r_a13e58fca02f174fa9bd72475840e51cc"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a13e58fca02f174fa9bd72475840e51cc">maybe_delete_a_numbered_dir</a> (Path path)</td></tr>
<tr class="separator:a13e58fca02f174fa9bd72475840e51cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3f573b2bcd340dc200f85899715bfa" id="r_a1c3f573b2bcd340dc200f85899715bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a1c3f573b2bcd340dc200f85899715bfa">ensure_deletable</a> (Path path, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a1c3f573b2bcd340dc200f85899715bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a716332cee4b0ffe6806ccfd56c390" id="r_a94a716332cee4b0ffe6806ccfd56c390"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a94a716332cee4b0ffe6806ccfd56c390">try_cleanup</a> (Path path, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a94a716332cee4b0ffe6806ccfd56c390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae357103ea4a06ecb2d8bd3b18af4ea53" id="r_ae357103ea4a06ecb2d8bd3b18af4ea53"><td class="memItemLeft" align="right" valign="top">Iterator[Path]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#ae357103ea4a06ecb2d8bd3b18af4ea53">cleanup_candidates</a> (Path root, str prefix, int keep)</td></tr>
<tr class="separator:ae357103ea4a06ecb2d8bd3b18af4ea53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029804adc1a9bf460f063bad46dade6a" id="r_a029804adc1a9bf460f063bad46dade6a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a029804adc1a9bf460f063bad46dade6a">cleanup_dead_symlinks</a> (Path root)</td></tr>
<tr class="separator:a029804adc1a9bf460f063bad46dade6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1e52490b7f908dbc8b6041d0bba697" id="r_a9d1e52490b7f908dbc8b6041d0bba697"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a9d1e52490b7f908dbc8b6041d0bba697">cleanup_numbered_dir</a> (Path root, str prefix, int keep, float consider_lock_dead_if_created_before)</td></tr>
<tr class="separator:a9d1e52490b7f908dbc8b6041d0bba697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cda2f173f0946adac7122c00608b88" id="r_a31cda2f173f0946adac7122c00608b88"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a31cda2f173f0946adac7122c00608b88">make_numbered_dir_with_cleanup</a> (Path root, str prefix, int keep, float lock_timeout, int mode)</td></tr>
<tr class="separator:a31cda2f173f0946adac7122c00608b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d692771185c792d8b0f888953061d9" id="r_a16d692771185c792d8b0f888953061d9"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a16d692771185c792d8b0f888953061d9">resolve_from_str</a> (str input, Path rootpath)</td></tr>
<tr class="separator:a16d692771185c792d8b0f888953061d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1004d7bebd54d347c235848846e2e8" id="r_a6b1004d7bebd54d347c235848846e2e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6b1004d7bebd54d347c235848846e2e8">fnmatch_ex</a> (str pattern, str|os.PathLike[str] path)</td></tr>
<tr class="separator:a6b1004d7bebd54d347c235848846e2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb98e10060724ec1d7bcffc434ee55d8" id="r_afb98e10060724ec1d7bcffc434ee55d8"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#afb98e10060724ec1d7bcffc434ee55d8">parts</a> (str s)</td></tr>
<tr class="separator:afb98e10060724ec1d7bcffc434ee55d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f2306195bc2afab763d5bd8c20ae9d" id="r_a96f2306195bc2afab763d5bd8c20ae9d"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a96f2306195bc2afab763d5bd8c20ae9d">symlink_or_skip</a> (os.PathLike[str]|str src, os.PathLike[str]|str dst, **Any kwargs)</td></tr>
<tr class="separator:a96f2306195bc2afab763d5bd8c20ae9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d50d4be59231686238c26254397989" id="r_a85d50d4be59231686238c26254397989"><td class="memItemLeft" align="right" valign="top">ModuleType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a85d50d4be59231686238c26254397989">import_path</a> (str|os.PathLike[str] path, *str|<a class="el" href="class__pytest_1_1pathlib_1_1ImportMode.html">ImportMode</a> mode=<a class="el" href="class__pytest_1_1pathlib_1_1ImportMode.html#a3c8859503e2fee8e08c242b769efe1b8">ImportMode.prepend</a>, Path root, bool consider_namespace_packages)</td></tr>
<tr class="separator:a85d50d4be59231686238c26254397989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138872e68e84e677b1011d34000996c8" id="r_a138872e68e84e677b1011d34000996c8"><td class="memItemLeft" align="right" valign="top">ModuleType|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a138872e68e84e677b1011d34000996c8">_import_module_using_spec</a> (str module_name, Path module_path, Path module_location, *bool insert_modules)</td></tr>
<tr class="separator:a138872e68e84e677b1011d34000996c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500b7dde594bf79fd876fcb912114d9f" id="r_a500b7dde594bf79fd876fcb912114d9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a500b7dde594bf79fd876fcb912114d9f">spec_matches_module_path</a> (ModuleSpec|None module_spec, Path module_path)</td></tr>
<tr class="separator:a500b7dde594bf79fd876fcb912114d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b07abdf23e0fb0d65477da791e92ab" id="r_a40b07abdf23e0fb0d65477da791e92ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a40b07abdf23e0fb0d65477da791e92ab">_is_same</a> (str f1, str f2)</td></tr>
<tr class="separator:a40b07abdf23e0fb0d65477da791e92ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627c18aa62422d2db2f1ad51382f5afd" id="r_a627c18aa62422d2db2f1ad51382f5afd"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a627c18aa62422d2db2f1ad51382f5afd">module_name_from_path</a> (Path path, Path root)</td></tr>
<tr class="separator:a627c18aa62422d2db2f1ad51382f5afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda9be6ad7371c8275fd7e08928726c5" id="r_acda9be6ad7371c8275fd7e08928726c5"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#acda9be6ad7371c8275fd7e08928726c5">insert_missing_modules</a> (dict[str, ModuleType] modules, str module_name)</td></tr>
<tr class="separator:acda9be6ad7371c8275fd7e08928726c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca58c69dc664a8394910cb98591c2c3e" id="r_aca58c69dc664a8394910cb98591c2c3e"><td class="memItemLeft" align="right" valign="top">Path|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#aca58c69dc664a8394910cb98591c2c3e">resolve_package_path</a> (Path path)</td></tr>
<tr class="separator:aca58c69dc664a8394910cb98591c2c3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537608ed00fe02d04a7f964be5a237f5" id="r_a537608ed00fe02d04a7f964be5a237f5"><td class="memItemLeft" align="right" valign="top">tuple[Path, str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a537608ed00fe02d04a7f964be5a237f5">resolve_pkg_root_and_module_name</a> (Path path, *bool consider_namespace_packages=False)</td></tr>
<tr class="separator:a537608ed00fe02d04a7f964be5a237f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40ce40c87f5e694865f40cbfa267f3c" id="r_af40ce40c87f5e694865f40cbfa267f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#af40ce40c87f5e694865f40cbfa267f3c">is_importable</a> (str module_name, Path module_path)</td></tr>
<tr class="separator:af40ce40c87f5e694865f40cbfa267f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95648f8e99507feb1f5978aaa70877f7" id="r_a95648f8e99507feb1f5978aaa70877f7"><td class="memItemLeft" align="right" valign="top">str|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a95648f8e99507feb1f5978aaa70877f7">compute_module_name</a> (Path root, Path module_path)</td></tr>
<tr class="separator:a95648f8e99507feb1f5978aaa70877f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7902afd9185410d7886e257cfa28d6d0" id="r_a7902afd9185410d7886e257cfa28d6d0"><td class="memItemLeft" align="right" valign="top">list[os.DirEntry[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a7902afd9185410d7886e257cfa28d6d0">scandir</a> (str|os.PathLike[str] path, Callable[[os.DirEntry[str]], object] sort_key=lambda entry:entry.name)</td></tr>
<tr class="separator:a7902afd9185410d7886e257cfa28d6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c510d7d87a1bd007c78df762338f1e" id="r_a93c510d7d87a1bd007c78df762338f1e"><td class="memItemLeft" align="right" valign="top">Iterator[os.DirEntry[str]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a93c510d7d87a1bd007c78df762338f1e">visit</a> (str|os.PathLike[str] path, Callable[[os.DirEntry[str]], bool] recurse)</td></tr>
<tr class="separator:a93c510d7d87a1bd007c78df762338f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3711f7c9b726c90c56e71a74a6644153" id="r_a3711f7c9b726c90c56e71a74a6644153"><td class="memItemLeft" align="right" valign="top">Path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a3711f7c9b726c90c56e71a74a6644153">absolutepath</a> (str|os.PathLike[str] path)</td></tr>
<tr class="separator:a3711f7c9b726c90c56e71a74a6644153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36570346e402c40e0ce5a83af6f33ab0" id="r_a36570346e402c40e0ce5a83af6f33ab0"><td class="memItemLeft" align="right" valign="top">Path|None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a36570346e402c40e0ce5a83af6f33ab0">commonpath</a> (Path path1, Path path2)</td></tr>
<tr class="separator:a36570346e402c40e0ce5a83af6f33ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551b7399b00c9a5673964d7a3e299f2f" id="r_a551b7399b00c9a5673964d7a3e299f2f"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a551b7399b00c9a5673964d7a3e299f2f">bestrelpath</a> (Path directory, Path dest)</td></tr>
<tr class="separator:a551b7399b00c9a5673964d7a3e299f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477136b449c5773df097dd9410c8c3d1" id="r_a477136b449c5773df097dd9410c8c3d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a477136b449c5773df097dd9410c8c3d1">safe_exists</a> (Path p)</td></tr>
<tr class="separator:a477136b449c5773df097dd9410c8c3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6c097e7a2732274f1e66f46e679d3fe2" id="r_a6c097e7a2732274f1e66f46e679d3fe2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a6c097e7a2732274f1e66f46e679d3fe2">LOCK_TIMEOUT</a> = 60 * 60 * 24 * 3</td></tr>
<tr class="separator:a6c097e7a2732274f1e66f46e679d3fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa54319ebbb1846a29cd4ad31da4d4" id="r_a0eaa54319ebbb1846a29cd4ad31da4d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> = TypeVar(&quot;_AnyPurePath&quot;, bound=PurePath)</td></tr>
<tr class="separator:a0eaa54319ebbb1846a29cd4ad31da4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4098dd7db7f37942e4d1e4898051a34d" id="r_a4098dd7db7f37942e4d1e4898051a34d"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a4098dd7db7f37942e4d1e4898051a34d">_IGNORED_ERRORS</a> = (ENOENT, ENOTDIR, EBADF, ELOOP)</td></tr>
<tr class="separator:a4098dd7db7f37942e4d1e4898051a34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dcc98dfd4f9e8e52ff548aaf17b6e8" id="r_a82dcc98dfd4f9e8e52ff548aaf17b6e8"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace__pytest_1_1pathlib.html#a82dcc98dfd4f9e8e52ff548aaf17b6e8">_IGNORED_WINERRORS</a></td></tr>
<tr class="separator:a82dcc98dfd4f9e8e52ff548aaf17b6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2d36d17900127934577a8859d235bcfd" name="a2d36d17900127934577a8859d235bcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d36d17900127934577a8859d235bcfd">&#9670;&#160;</a></span>_force_symlink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib._force_symlink </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | PurePath&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | Path&#160;</td>
          <td class="paramname"><em>link_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper to create the current symlink.

It's full of race conditions that are reasonably OK to ignore
for the context of best effort linking to the latest test run.

The presumption being that in case of much parallelism
the inaccuracy is going to be acceptable.
</pre> 
</div>
</div>
<a id="a49fb18e734de79bf93247d67a201673b" name="a49fb18e734de79bf93247d67a201673b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fb18e734de79bf93247d67a201673b">&#9670;&#160;</a></span>_ignore_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib._ignore_error </td>
          <td>(</td>
          <td class="paramtype">Exception&#160;</td>
          <td class="paramname"><em>exception</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a138872e68e84e677b1011d34000996c8" name="a138872e68e84e677b1011d34000996c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138872e68e84e677b1011d34000996c8">&#9670;&#160;</a></span>_import_module_using_spec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType | None _pytest.pathlib._import_module_using_spec </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>module_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>module_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>module_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool
&#160;</td>
          <td class="paramname"><em>insert_modules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Tries to import a module by its canonical name, path, and its parent location.

:param module_name:
    The expected module name, will become the key of `sys.modules`.

:param module_path:
    The file path of the module, for example `/foo/bar/test_demo.py`.
    If module is a package, pass the path to the  `__init__.py` of the package.
    If module is a namespace package, pass directory path.

:param module_location:
    The parent location of the module.
    If module is a package, pass the directory containing the `__init__.py` file.

:param insert_modules:
    If True, will call `insert_missing_modules` to create empty intermediate modules
    with made-up module names (when importing test files not reachable from `sys.path`).

Example 1 of parent_module_*:

    module_name:        "a.b.c.demo"
    module_path:        Path("a/b/c/demo.py")
    module_location:    Path("a/b/c/")
    if "a.b.c" is package ("a/b/c/__init__.py" exists), then
        parent_module_name:         "a.b.c"
        parent_module_path:         Path("a/b/c/__init__.py")
        parent_module_location:     Path("a/b/c/")
    else:
        parent_module_name:         "a.b.c"
        parent_module_path:         Path("a/b/c")
        parent_module_location:     Path("a/b/")

Example 2 of parent_module_*:

    module_name:        "a.b.c"
    module_path:        Path("a/b/c/__init__.py")
    module_location:    Path("a/b/c/")
    if  "a.b" is package ("a/b/__init__.py" exists), then
        parent_module_name:         "a.b"
        parent_module_path:         Path("a/b/__init__.py")
        parent_module_location:     Path("a/b/")
    else:
        parent_module_name:         "a.b"
        parent_module_path:         Path("a/b/")
        parent_module_location:     Path("a/")
</pre> 
</div>
</div>
<a id="a40b07abdf23e0fb0d65477da791e92ab" name="a40b07abdf23e0fb0d65477da791e92ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b07abdf23e0fb0d65477da791e92ab">&#9670;&#160;</a></span>_is_same()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool _pytest.pathlib._is_same </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>f2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3711f7c9b726c90c56e71a74a6644153" name="a3711f7c9b726c90c56e71a74a6644153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3711f7c9b726c90c56e71a74a6644153">&#9670;&#160;</a></span>absolutepath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.absolutepath </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to an absolute path using os.path.abspath.

Prefer this over Path.resolve() (see #6523).
Prefer this over Path.absolute() (not public, doesn't normalize).
</pre> 
</div>
</div>
<a id="a551b7399b00c9a5673964d7a3e299f2f" name="a551b7399b00c9a5673964d7a3e299f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551b7399b00c9a5673964d7a3e299f2f">&#9670;&#160;</a></span>bestrelpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.bestrelpath </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string which is a relative path from directory to dest such
that directory/bestrelpath == dest.

The paths must be either both absolute or both relative.

If no such path can be determined, returns dest.
</pre> 
</div>
</div>
<a id="ae357103ea4a06ecb2d8bd3b18af4ea53" name="ae357103ea4a06ecb2d8bd3b18af4ea53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae357103ea4a06ecb2d8bd3b18af4ea53">&#9670;&#160;</a></span>cleanup_candidates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[Path] _pytest.pathlib.cleanup_candidates </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">List candidates for numbered directories to be removed - follows py.path.</pre> 
</div>
</div>
<a id="a029804adc1a9bf460f063bad46dade6a" name="a029804adc1a9bf460f063bad46dade6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029804adc1a9bf460f063bad46dade6a">&#9670;&#160;</a></span>cleanup_dead_symlinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.cleanup_dead_symlinks </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d1e52490b7f908dbc8b6041d0bba697" name="a9d1e52490b7f908dbc8b6041d0bba697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1e52490b7f908dbc8b6041d0bba697">&#9670;&#160;</a></span>cleanup_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.cleanup_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float
&#160;</td>
          <td class="paramname"><em>consider_lock_dead_if_created_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cleanup for lock driven numbered directories.</pre> 
</div>
</div>
<a id="a36570346e402c40e0ce5a83af6f33ab0" name="a36570346e402c40e0ce5a83af6f33ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36570346e402c40e0ce5a83af6f33ab0">&#9670;&#160;</a></span>commonpath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path | None _pytest.pathlib.commonpath </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the common part shared with the other path, or None if there is
no common part.

If one path is relative and one is absolute, returns None.
</pre> 
</div>
</div>
<a id="a95648f8e99507feb1f5978aaa70877f7" name="a95648f8e99507feb1f5978aaa70877f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95648f8e99507feb1f5978aaa70877f7">&#9670;&#160;</a></span>compute_module_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str | None _pytest.pathlib.compute_module_name </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>module_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a module name based on a path and a root anchor.</pre> 
</div>
</div>
<a id="a2fae1b99c0fbb9d314aceb95e668a401" name="a2fae1b99c0fbb9d314aceb95e668a401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fae1b99c0fbb9d314aceb95e668a401">&#9670;&#160;</a></span>create_cleanup_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.create_cleanup_lock </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a lock to prevent premature folder cleanup.</pre> 
</div>
</div>
<a id="a1c3f573b2bcd340dc200f85899715bfa" name="a1c3f573b2bcd340dc200f85899715bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3f573b2bcd340dc200f85899715bfa">&#9670;&#160;</a></span>ensure_deletable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.ensure_deletable </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>consider_lock_dead_if_created_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if `path` is deletable based on whether the lock file is expired.</pre> 
</div>
</div>
<a id="a6b8b0325e6efac0c038f9a724ab8a2bf" name="a6b8b0325e6efac0c038f9a724ab8a2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8b0325e6efac0c038f9a724ab8a2bf">&#9670;&#160;</a></span>ensure_extended_length_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.ensure_extended_length_path </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the extended-length version of a path (Windows).

On Windows, by default, the maximum length of a path (MAX_PATH) is 260
characters, and operations on paths longer than that fail. But it is possible
to overcome this by converting the path to "extended-length" form before
performing the operation:
https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#maximum-path-length-limitation

On Windows, this function returns the extended-length absolute version of path.
On other platforms it returns path unchanged.
</pre> 
</div>
</div>
<a id="a0addba70a654b247e36cb4401bc7dc12" name="a0addba70a654b247e36cb4401bc7dc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0addba70a654b247e36cb4401bc7dc12">&#9670;&#160;</a></span>extract_suffixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] _pytest.pathlib.extract_suffixes </td>
          <td>(</td>
          <td class="paramtype">Iterable[os.DirEntry[str]]&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the parts of the paths following the prefix.

:param iter: Iterator over path names.
:param prefix: Expected prefix of the path names.
</pre> 
</div>
</div>
<a id="ab1843653a064d8dee4dcf9a5cc00679c" name="ab1843653a064d8dee4dcf9a5cc00679c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1843653a064d8dee4dcf9a5cc00679c">&#9670;&#160;</a></span>find_prefixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[os.DirEntry[str]] _pytest.pathlib.find_prefixed </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all elements in root that begin with the prefix, case-insensitive.</pre> 
</div>
</div>
<a id="ae5a66215e40cad20f751eddc3c6e8721" name="ae5a66215e40cad20f751eddc3c6e8721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a66215e40cad20f751eddc3c6e8721">&#9670;&#160;</a></span>find_suffixes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[str] _pytest.pathlib.find_suffixes </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Combine find_prefixes and extract_suffixes.</pre> 
</div>
</div>
<a id="a6b1004d7bebd54d347c235848846e2e8" name="a6b1004d7bebd54d347c235848846e2e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1004d7bebd54d347c235848846e2e8">&#9670;&#160;</a></span>fnmatch_ex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.fnmatch_ex </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A port of FNMatcher from py.path.common which works with PurePath() instances.

The difference between this algorithm and PurePath.match() is that the
latter matches "**" glob expressions for each part of the path, while
this algorithm uses the whole path instead.

For example:
    "tests/foo/bar/doc/test_foo.py" matches pattern "tests/**/doc/test*.py"
    with this algorithm, but not with PurePath.match().

This algorithm was ported to keep backward-compatibility with existing
settings which assume paths match according this logic.

References:
* https://bugs.python.org/issue29249
* https://bugs.python.org/issue34731
</pre> 
</div>
</div>
<a id="ae544da450e5c7c6870a70be7cabc75d8" name="ae544da450e5c7c6870a70be7cabc75d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae544da450e5c7c6870a70be7cabc75d8">&#9670;&#160;</a></span>get_extended_length_path_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.get_extended_length_path_str </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a path to a Windows extended length path.</pre> 
</div>
</div>
<a id="a71cc9f2b91e8d7c2f31e80cc596fc1ad" name="a71cc9f2b91e8d7c2f31e80cc596fc1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cc9f2b91e8d7c2f31e80cc596fc1ad">&#9670;&#160;</a></span>get_lock_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a> _pytest.pathlib.get_lock_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace__pytest_1_1pathlib.html#a0eaa54319ebbb1846a29cd4ad31da4d4">_AnyPurePath</a>&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a85d50d4be59231686238c26254397989" name="a85d50d4be59231686238c26254397989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d50d4be59231686238c26254397989">&#9670;&#160;</a></span>import_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ModuleType _pytest.pathlib.import_path </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*str | <a class="el" href="class__pytest_1_1pathlib_1_1ImportMode.html">ImportMode</a> &#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class__pytest_1_1pathlib_1_1ImportMode.html#a3c8859503e2fee8e08c242b769efe1b8">ImportMode.prepend</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>consider_namespace_packages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Import and return a module from the given path, which can be a file (a module) or
a directory (a package).

:param path:
    Path to the file to import.

:param mode:
    Controls the underlying import mechanism that will be used:

    * ImportMode.prepend: the directory containing the module (or package, taking
      `__init__.py` files into account) will be put at the *start* of `sys.path` before
      being imported with `importlib.import_module`.

    * ImportMode.append: same as `prepend`, but the directory will be appended
      to the end of `sys.path`, if not already in `sys.path`.

    * ImportMode.importlib: uses more fine control mechanisms provided by `importlib`
      to import the module, which avoids having to muck with `sys.path` at all. It effectively
      allows having same-named test modules in different places.

:param root:
    Used as an anchor when mode == ImportMode.importlib to obtain
    a unique name for the module being imported so it can safely be stored
    into ``sys.modules``.

:param consider_namespace_packages:
    If True, consider namespace packages when resolving module names.

:raises ImportPathMismatchError:
    If after importing the given `path` and the module `__file__`
    are different. Only raised in `prepend` and `append` modes.
</pre> 
</div>
</div>
<a id="acda9be6ad7371c8275fd7e08928726c5" name="acda9be6ad7371c8275fd7e08928726c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda9be6ad7371c8275fd7e08928726c5">&#9670;&#160;</a></span>insert_missing_modules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.insert_missing_modules </td>
          <td>(</td>
          <td class="paramtype">dict[str, ModuleType]&#160;</td>
          <td class="paramname"><em>modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>module_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Used by ``import_path`` to create intermediate modules when using mode=importlib.

When we want to import a module as "src.tests.test_foo" for example, we need
to create empty modules "src" and "src.tests" after inserting "src.tests.test_foo",
otherwise "src.tests.test_foo" is not importable by ``__import__``.
</pre> 
</div>
</div>
<a id="af40ce40c87f5e694865f40cbfa267f3c" name="af40ce40c87f5e694865f40cbfa267f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40ce40c87f5e694865f40cbfa267f3c">&#9670;&#160;</a></span>is_importable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.is_importable </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>module_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>module_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return if the given module path could be imported normally by Python, akin to the user
entering the REPL and importing the corresponding module name directly, and corresponds
to the module_path specified.

:param module_name:
    Full module name that we want to check if is importable.
    For example, "app.models".

:param module_path:
    Full path to the python module/package we want to check if is importable.
    For example, "/projects/src/app/models.py".
</pre> 
</div>
</div>
<a id="a6ca62f92c9e61a349836eadf38245d85" name="a6ca62f92c9e61a349836eadf38245d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca62f92c9e61a349836eadf38245d85">&#9670;&#160;</a></span>make_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.make_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>mode</em> = <code>0o700</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a directory with an increased number as suffix for the given prefix.</pre> 
</div>
</div>
<a id="a31cda2f173f0946adac7122c00608b88" name="a31cda2f173f0946adac7122c00608b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31cda2f173f0946adac7122c00608b88">&#9670;&#160;</a></span>make_numbered_dir_with_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.make_numbered_dir_with_cleanup </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>keep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>lock_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a numbered dir with a cleanup lock and remove old ones.</pre> 
</div>
</div>
<a id="a13e58fca02f174fa9bd72475840e51cc" name="a13e58fca02f174fa9bd72475840e51cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e58fca02f174fa9bd72475840e51cc">&#9670;&#160;</a></span>maybe_delete_a_numbered_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.maybe_delete_a_numbered_dir </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove a numbered directory if its lock can be obtained and it does
not seem to be in use.</pre> 
</div>
</div>
<a id="a627c18aa62422d2db2f1ad51382f5afd" name="a627c18aa62422d2db2f1ad51382f5afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627c18aa62422d2db2f1ad51382f5afd">&#9670;&#160;</a></span>module_name_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> str _pytest.pathlib.module_name_from_path </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dotted module name based on the given path, anchored on root.

For example: path="projects/src/tests/test_foo.py" and root="/projects", the
resulting module name will be "src.tests.test_foo".
</pre> 
</div>
</div>
<a id="a1abdcb5994f4fa50d164263b77b2e17c" name="a1abdcb5994f4fa50d164263b77b2e17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abdcb5994f4fa50d164263b77b2e17c">&#9670;&#160;</a></span>on_rm_rf_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.on_rm_rf_error </td>
          <td>(</td>
          <td class="paramtype">Callable[..., Any] | None&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BaseException
    | tuple[type[BaseException], BaseException, types.TracebackType | None]&#160;</td>
          <td class="paramname"><em>excinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*Path&#160;</td>
          <td class="paramname"><em>start_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Handle known read-only errors during rmtree.

The returned value is used only by our own tests.
</pre> 
</div>
</div>
<a id="aef6232b74550a186a8206597eefc3737" name="aef6232b74550a186a8206597eefc3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6232b74550a186a8206597eefc3737">&#9670;&#160;</a></span>parse_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int _pytest.pathlib.parse_num </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>maybe_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse number path suffixes, returns -1 on error.</pre> 
</div>
</div>
<a id="afb98e10060724ec1d7bcffc434ee55d8" name="afb98e10060724ec1d7bcffc434ee55d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb98e10060724ec1d7bcffc434ee55d8">&#9670;&#160;</a></span>parts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> set[str] _pytest.pathlib.parts </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a18e8d477b40f4178236b4e1a1465e550" name="a18e8d477b40f4178236b4e1a1465e550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18e8d477b40f4178236b4e1a1465e550">&#9670;&#160;</a></span>register_cleanup_lock_removal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Any _pytest.pathlib.register_cleanup_lock_removal </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>lock_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any &#160;</td>
          <td class="paramname"><em>register</em> = <code>atexit.register</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Register a cleanup function for removing a lock, by default on atexit.</pre> 
</div>
</div>
<a id="a16d692771185c792d8b0f888953061d9" name="a16d692771185c792d8b0f888953061d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d692771185c792d8b0f888953061d9">&#9670;&#160;</a></span>resolve_from_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path _pytest.pathlib.resolve_from_str </td>
          <td>(</td>
          <td class="paramtype">str&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>rootpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca58c69dc664a8394910cb98591c2c3e" name="aca58c69dc664a8394910cb98591c2c3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca58c69dc664a8394910cb98591c2c3e">&#9670;&#160;</a></span>resolve_package_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Path | None _pytest.pathlib.resolve_package_path </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Python package path by looking for the last
directory upwards which still contains an __init__.py.

Returns None if it cannot be determined.
</pre> 
</div>
</div>
<a id="a537608ed00fe02d04a7f964be5a237f5" name="a537608ed00fe02d04a7f964be5a237f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537608ed00fe02d04a7f964be5a237f5">&#9670;&#160;</a></span>resolve_pkg_root_and_module_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[Path, str] _pytest.pathlib.resolve_pkg_root_and_module_name </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*bool &#160;</td>
          <td class="paramname"><em>consider_namespace_packages</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the path to the directory of the root package that contains the
given Python file, and its module name:

    src/
        app/
            __init__.py
            core/
                __init__.py
                models.py

Passing the full path to `models.py` will yield Path("src") and "app.core.models".

If consider_namespace_packages is True, then we additionally check upwards in the hierarchy
for namespace packages:

https://packaging.python.org/en/latest/guides/packaging-namespace-packages

Raises CouldNotResolvePathError if the given path does not belong to a package (missing any __init__.py files).
</pre> 
</div>
</div>
<a id="ae1f0c08537ab64dd461cfb6674625b38" name="ae1f0c08537ab64dd461cfb6674625b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f0c08537ab64dd461cfb6674625b38">&#9670;&#160;</a></span>rm_rf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.rm_rf </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Remove the path contents recursively, even if some elements
are read-only.</pre> 
</div>
</div>
<a id="a477136b449c5773df097dd9410c8c3d1" name="a477136b449c5773df097dd9410c8c3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477136b449c5773df097dd9410c8c3d1">&#9670;&#160;</a></span>safe_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.safe_exists </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Like Path.exists(), but account for input arguments that might be too long (#11394).</pre> 
</div>
</div>
<a id="a7902afd9185410d7886e257cfa28d6d0" name="a7902afd9185410d7886e257cfa28d6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7902afd9185410d7886e257cfa28d6d0">&#9670;&#160;</a></span>scandir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[os.DirEntry[str]] _pytest.pathlib.scandir </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[os.DirEntry[str]], object] &#160;</td>
          <td class="paramname"><em>sort_key</em> = <code>lambda&#160;entry:&#160;entry.name</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Scan a directory recursively, in breadth-first order.

The returned entries are sorted according to the given key.
The default is to sort by name.
If the directory does not exist, return an empty list.
</pre> 
</div>
</div>
<a id="a500b7dde594bf79fd876fcb912114d9f" name="a500b7dde594bf79fd876fcb912114d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500b7dde594bf79fd876fcb912114d9f">&#9670;&#160;</a></span>spec_matches_module_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool _pytest.pathlib.spec_matches_module_path </td>
          <td>(</td>
          <td class="paramtype">ModuleSpec | None&#160;</td>
          <td class="paramname"><em>module_spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>module_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return true if the given ModuleSpec can be used to import the given module path.</pre> 
</div>
</div>
<a id="a96f2306195bc2afab763d5bd8c20ae9d" name="a96f2306195bc2afab763d5bd8c20ae9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f2306195bc2afab763d5bd8c20ae9d">&#9670;&#160;</a></span>symlink_or_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.symlink_or_skip </td>
          <td>(</td>
          <td class="paramtype">os.PathLike[str] | str&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">os.PathLike[str] | str&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**Any&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a symlink, or skip the test in case symlinks are not supported.</pre> 
</div>
</div>
<a id="a94a716332cee4b0ffe6806ccfd56c390" name="a94a716332cee4b0ffe6806ccfd56c390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94a716332cee4b0ffe6806ccfd56c390">&#9670;&#160;</a></span>try_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None _pytest.pathlib.try_cleanup </td>
          <td>(</td>
          <td class="paramtype">Path&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>consider_lock_dead_if_created_before</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Try to cleanup a folder if we can ensure it's deletable.</pre> 
</div>
</div>
<a id="a93c510d7d87a1bd007c78df762338f1e" name="a93c510d7d87a1bd007c78df762338f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c510d7d87a1bd007c78df762338f1e">&#9670;&#160;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Iterator[os.DirEntry[str]] _pytest.pathlib.visit </td>
          <td>(</td>
          <td class="paramtype">str | os.PathLike[str]&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable[[os.DirEntry[str]], bool]
&#160;</td>
          <td class="paramname"><em>recurse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Walk a directory recursively, in breadth-first order.

The `recurse` predicate determines whether a directory is recursed.

Entries at each directory level are sorted.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0eaa54319ebbb1846a29cd4ad31da4d4" name="a0eaa54319ebbb1846a29cd4ad31da4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaa54319ebbb1846a29cd4ad31da4d4">&#9670;&#160;</a></span>_AnyPurePath</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">_pytest.pathlib._AnyPurePath = TypeVar(&quot;_AnyPurePath&quot;, bound=PurePath)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4098dd7db7f37942e4d1e4898051a34d" name="a4098dd7db7f37942e4d1e4898051a34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4098dd7db7f37942e4d1e4898051a34d">&#9670;&#160;</a></span>_IGNORED_ERRORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple _pytest.pathlib._IGNORED_ERRORS = (ENOENT, ENOTDIR, EBADF, ELOOP)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dcc98dfd4f9e8e52ff548aaf17b6e8" name="a82dcc98dfd4f9e8e52ff548aaf17b6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dcc98dfd4f9e8e52ff548aaf17b6e8">&#9670;&#160;</a></span>_IGNORED_WINERRORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple _pytest.pathlib._IGNORED_WINERRORS</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><span class="lineno">    1</span>=  (</div>
<div class="line"><span class="lineno">    2</span>    21,  <span class="comment"># ERROR_NOT_READY - drive exists but is not accessible</span></div>
<div class="line"><span class="lineno">    3</span>    1921,  <span class="comment"># ERROR_CANT_RESOLVE_FILENAME - fix for broken symlink pointing to itself</span></div>
<div class="line"><span class="lineno">    4</span>)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6c097e7a2732274f1e66f46e679d3fe2" name="a6c097e7a2732274f1e66f46e679d3fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c097e7a2732274f1e66f46e679d3fe2">&#9670;&#160;</a></span>LOCK_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int _pytest.pathlib.LOCK_TIMEOUT = 60 * 60 * 24 * 3</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
